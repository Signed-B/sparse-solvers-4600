clc; clear; close all;

n=50; %number points per direction

x1=0; %bounrdries
x2=1;
y1=0;
y2=1; 

%assumes constant space in both direction (with break otherwise)
h=(x2-x1)/(n-1); %spacing

%Domain (100 different ways)
[grid_x,grid_y]=meshgrid(x1:h:x2,y1:h:y2);
Dx=linspace(x1,x2,n);
Dy=linspace(y1,y2,n);
D=zeros(n^2,2);
D(1,1)=x1; 
for i=1:n^2-1
    D(i+1,1)=Dx(mod(i,n)+1);
    D(i+1,2)=Dy(floor(i/n)+1);
end


A=zeros(n^2,n^2); %creates empty variables
rhs=zeros(n^2,1);

for i=1:n^2
    on_boundry=0; %boundry boolean
    if i<=n || i>n^2-n || mod(i,n)==0 || mod(i,n)==1  %checks if u_i is on boundry
        on_boundry=1;
        rhs(i)=g(D(i,1),D(i,2)); %if yes rhs is boundry function
        A(i,i)=1; %corresponding row in A is just part of identity
    else
        rhs(i)=f(D(i,1),D(i,2)); %if not rhs is f
        for j=1:n^2
            A(i,i)=-4/h^2; %approximates second derivvative
            A(i,i+1)=1/h^2;
            A(i,i-1)=1/h^2;
            A(i,i+(n))=1/h^2;
            A(i,i-(n))=1/h^2;
        end
    end
end

U=A\rhs; %solves system

grid_u=zeros(n,n); %converst solution back to matrix form
for i=1:n
    for j=1:n
        grid_u(i,j)=U(n*(i-1)+j);
    end
end

surface(grid_x,grid_y,grid_u) %plots solution

% calcs and plot actual
[real_x,real_y]=meshgrid(x1:(x2-x1)/:x2,y1:h:y2);


function [A,rhs,D]=poisson_setup(x1,x2,y1,y2,n,f,g)
    %A is matrix, rhs is randhand side, D is domain of finite difference
    %points
    %x1,x2,y1,y2 define interval of interest
    %n is number of point in each direction
    %f is rhs of poisson equation
    %g is function gives value of u along broundry of domain

    %assumes function is zero homogenous dirichlet boundry conditions
    %(might change to matches second derivative around edges of givven
    %function).


    


end

function [z]=f(x,y) %rhs forcing function
    z=-8*pi^2*sin(2*pi*y).*sin(2*pi*x);
end

function [z]=g(x,y) %broundry condition function
    z=0;
end

function [z]=actual(x,y) %solution to ivp
    z=sin(2*pi*x).*sin(2*pi*y);
end